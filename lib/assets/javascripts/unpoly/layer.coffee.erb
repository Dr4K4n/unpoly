u = up.util
e = up.element

up.layer = do ->

  OVERLAY_CLASSES = [
    up.Layer.Root
    up.Layer.Modal
    up.Layer.Popup
    up.Layer.Drawer
    up.Layer.Cover
  ]

  # TODO: Document up.layer.config
  config = new up.Config ->
    newConfig =
      mode: 'modal'
      all:
        # Define a default target that will close all overlays
        # and show an unpexpected response in the <body>
        targets: [{ layer: 'root', target: 'body', peel: true }]
      root:
        targets: []
      overlay:
        targets: []
        history: true
        openAnimation: 'fade-in'
        closeAnimation: 'fade-out'
        backdropOpenAnimation: 'fade-in'
        backdropCloseAnimation: 'fade-out'
        dismissLabel: 'Ã—'
        dismissAriaLabel: 'Dismiss dialog'
        dismissable: true
      cover:
        targets: []
      drawer:
        targets: []
        position: 'left'
        openAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-from-left'
            when 'right' then 'move-from-right'
        closeAnimation: (layer) ->
          switch layer.position
            when 'left' then 'move-to-left'
            when 'right' then 'move-to-right'
      modal:
        targets: []
      popup:
        targets: []
        position: 'bottom'
        align: 'left'
        history: false

    for Class in OVERLAY_CLASSES
      newConfig[Class.mode] = Class

    return newConfig

  stack = null

  handlers = []

  isOverlayMode = (name) ->
    !!config[name]?.Class

  overlaySelector = ->
    u.map(OVERLAY_CLASSES, (Class) -> Class.selector()).join(',')

  isOverlay = (element) ->
    e.matches(element, overlaySelector())

  defaultTargets = (mode) ->
    return u.flatMap(modeConfigs(mode), 'targets')

  ###**
  Returns an array of config objects that apply to the given mode name.

  The config objects are in descending order of specificity.
  ###
  modeConfigs = (mode = config.mode) ->
    if mode == 'root'
      return [config.root, config.all]
    else
      return [config[mode], config.overlay, config.all]

  build = (options) ->
    mode = options.mode ? config.mode
    Class = config[mode].Class
    configs = u.reverse(modeConfigs(mode))
    options = u.mergeDefined(configs..., { mode, stack }, options)
    return new Class(options)

#  modeClass = (options = {}) ->
#    mode = options.mode ? config.mode
#    config[mode].Class or up.fail("Unknown layer mode: #{mode}")

  openCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      new Function('event', code).bind(link)

  closeCallbackAttr = (link, attr) ->
    if code = link.getAttribute(attr)
      # Allow callbacks to refer to `value` directly instead of through `event.value`.
      callback = new Function('event', 'value', code)
      # Emulate the behavior of the `onclick` attribute,
      # where `this` refers to the clicked element.
      return (event) -> callback.call(link, event, event.value)

  reset = ->
    config.reset()
    stack.reset()
    handlers = u.filter(handlers, 'isDefault')

  open = (options) ->
    options = u.options(options, layer: 'new')

    # Even if we are given { content } we need to pipe this through up.change()
    # since a lot of options processing is happening there.
    return up.change(options)

  # TODO: Docs for up.layer.ask()
  ask = (options) ->
    return new Promise (resolve, reject) ->
      options = u.merge options,
        onAccepted: (event) -> resolve(event.value)
        onRejected: (event) -> reject(event.value)
      open(options)

  allElements = (selector, options) ->
    layers = stack.lookupAll(options)
    u.flatMap layers, (layer) -> layer.allElements(selector)

  firstElement = (selector, options) ->
    layers = stack.lookupAll(options)
    u.findResult layers, -> layer.firstElement(selector)

  ###**
  # Event handlers for [up-target] etc. are registered to each layer instead of
  # only once to the document. See https://github.com/unpoly/unpoly/issues/79
  #
  # @function up.layer.onEach
  # @internal
  ###
  registerHandler = (handler...) ->
    handler.isDefault = up.framework.isBooting()

    # Remember handler for future layers
    handlers.push(handler)

    # Apply to existing layers
    for layer in stack.layers
      layer.on(handler...)

  applyHandlers = (layer) ->
    for handler in handlers
      layer.on(handler...)

  up.event.onEscape (event) ->
    layer = stack.current
    if layer.escapeDismissable
      u.muteRejection layer.dismiss()
      up.event.halt(event)

  up.on 'up:framework:boot', ->
    # TODO: Docs for [up-modal]
    # TODO: Docs for [up-popup]
    # TODO: Docs for [up-drawer]
    # TODO: Docs for [up-cover]
    for Class in OVERLAY_CLASSES
      up.link.targetMacro Class.attr, 'up-layer': Class.mode

  registerCloseHandler = (attribute, closeFn) ->
    # Allow the fallbacks to be both vanilla links and Unpoly [up-target] links
    registerHandler 'click up:link:follow', "[#{attribute}]", (event) ->
      origin = event.target
      layer = stack.of(origin)
      # To make a view usable both as a root layer and as an overlay, the programmer might
      # define a fallback like this:
      #
      #     <a href="/fallback" up-accept>...</a>
      #
      # We only want to accept the layer (and halt the event chain) if that link is in an overlay.
      # If the link is in the root layer, we allow the event to bubble up.
      unless layer.isRoot()
        value = e.jsonAttr(origin, attribute)
        u.muteRejection closeFn(layer, { value, origin })
        # closeFn(layer, { value, origin })
        up.event.halt(event)

  up.on 'up:framework:boot', ->
    stack = new up.LayerStack()

    registerCloseHandler 'up-accept', (layer, closeOptions) ->
      return layer.accept(closeOptions)

    registerCloseHandler 'up-dismiss', (layer, closeOptions) ->
      return layer.dismiss(closeOptions)

    registerCloseHandler 'up-close', (layer, closeOptions) ->
      up.legacy.deprecated('[up-close]', '[up-dismiss]')
      return layer.dismiss(closeOptions)

  # The framework is reset between tests, so also close a currently open tooltip.
  up.on 'up:framework:reset', reset

  u.literal
    of: (args...) -> stack.of(args...)
    lookup: (args...) -> stack.lookupOne(args...)
    lookupAll: (args...) -> stack.lookupAll(args...)
    get_overlayContainer: -> stack.overlayContainer
    attachOverlayContainer: -> stack.attachOverlayContainer()
    allElements: allElements
    firstElement: firstElement
    config: config
    defaultTargets: defaultTargets
    open: open
    build: build
    accept: (args...) -> stack.current.accept(args...)
    dismiss: (args...) -> stack.current.dismiss(args...)
    sync: (args...) -> stack.current.sync(args...)
    openCallbackAttr: openCallbackAttr
    closeCallbackAttr: closeCallbackAttr
    isRoot: -> stack.isRoot()
    isOverlay: -> stack.isOverlay()
    push: (args...) -> stack.push(args...)
    isOverlayMode: isOverlayMode
    on: (args...) -> stack.current.on(args...)
    off: (args...) -> stack.current.off(args...)
    emit: (args...) -> stack.current.emit(args...)
    onEach: registerHandler
    applyHandlers: applyHandlers
    get_root: -> stack.root
    get_all: -> stack.layers
    get_current: -> stack.current
    get_leaf: -> stack.leaf
    get_parent: -> stack.parent
    parentOf: (args...) -> stack.parentOf(args...)
    get_location: -> stack.current.location
    get_history: -> stack.current.history
    get_title: -> stack.current.title
    get_mode: -> stack.current.mode
    get_position: -> stack.current.position
    get_element: -> stack.current.element
    get_context: -> stack.current.context
    contains: (args...) -> stack.current.contains(args...)

# TODO: Docs for up.context
u.getter(up, 'context', -> up.layer.context)
