- Check new layer styles visually
  - Nested layers should have more padding
  - Or maybe push background layers down and always keep the top modal at the same Y: https://atlaskit.atlassian.com/examples/core/modal-dialog/multiple
- Should we keep up.history.popTargets?
  - Should this always reset the world?
  - up.config.root.targets might not be appropriate
  - but the layer targets will always be options after .popTargets
- up.history.replace() is kinda dangerous API
  - the current layer still has the previous URL
- Move up.browser.location to up.history.location
- Have up.layer.build delegate to up.Layer class
- Make sure all Change#execute() functions check if they're still applicable (or if the layer has been removed)
- Allow to pass up.Layer instances as first arguments to up.emit(), up.on(), up.first() and up.all()
  - This requires some more changes than I thought
- Update Rails integration
  - up.layer.accept(value)
  - up.layer.dismiss(value)
  - up.layer.emit(name, props)
  - up.emit(name, props)
- Review up.Request#preflightLayer
  - This should always be set, even for new layers
  - Why is it Request#preflightLayer instead of #layer?
- Emit layer-bound proxy events with up.layer.emit(), not up.emit()
- Present tense events still have long-form event log messages with gerund
- up.layer.lookup and up.layer.lookupAll sound like they would take a value, but they only take an options hash
- up:fragment:inserted should receive the entire document from which the fragment was extracted
- Rename change({ document }) to change({ page })?
- Rename up.element.*fromHtml to ...fromHTML
- Reanem up.util.escapeHtml to up.util.escapeHTML
- I see no up:layer:opened events in the console?
- Check that up.layer forwards getters for all layer properties to stack.current
- Easy way to check that an error is an AbortError
  - We have isAbortError but Request#aborted
  - I think we should just do #aborted because it's easier to check
- Move abortRejection / abortError to up.error
- Opening a new layer should cancel requests that also open a new layer
- Reconsider if it should be .up-overlay (more precise) or .up-layer (shorter and expected)
  - I decided to go with "layer" to not introduce one more term for "overlay", "dialog", etc.
  - We want .up-layer, but keep .up-overlays
  - Re-re-name overlay.sass to layer.sass
- We now have unpoly-bootstrap3 and unpoly-bootstrap4
- Rework logging
  - Remove all groups
  - Distinguish between puts and debug
- Rename { flavor } to { mode }, provide legacy fallbacks
- Better name for up.fragment.config.resetWorld
- Fix unpoly-guide; The fullscreen-mode should just be up-mode="cover"
- Move up.log.sprintf to up.util.sprintf
- up.fragment.config.fallbackTransition wieder rein?
- up.fragment.config.fallbacks sollte auf up.fragment.config.targets delegieren, oder wir nennen { targets } um auf { fallbacks }
- Layer HTML doch wieder wie früher: .up-modal .up-modal-viewport .up-modal-frame .up-modal-content
- backdropDismissable => outsideDismissable


- Tests
  - Get tests green again
  - Test layer { context } transmission
  - Test that back button closes all layers
  - Test that up.change() can be called with { target: Element }
  - Test that up.change() can be called with { target: Element } and will find in any layer
  - Test that up.change() without { layer } option will only find in current layer
  - Test that clicking on the layer backdrop will cause dismiss on iOS (https://code.makandra.de/makandra/studyflix/commit/cf7d016a1d00797519b709cfcb27423c6adea9d2)
  - Test that [up-dismiss][up-follow] inside a layer will dismiss
  - Test that [up-dismiss][up-follow] outside a layer will follow
  - Test that peeling is not preventable by preventing up:layer:dismiss
  - Test that opening/updating an layer can reset the world if selector is unavailable
  - Test against https://github.com/unpoly/unpoly/issues/79
    - We might need to register all link handlers to a new .up-modal instead of the document
  - Test defaults inheritance in layer hierarchy
  - Test that a layer cannot have history: true if its parent has history: false
  - Test that making a layer change in an { onAccepted } callback will not deadlock the acceptance change
  - Test that layers are assigned .up-destroyed class while closing
  - Test that default targets are selectable per layer-type
  - Test that default targets are also fallbacks per layer-type
  - Test that that all layer methods manipulate the stack in sync (peel, push, remove)
    - E.g. opening the layer twice in a row fails currently: up.layer.open({ content: '<div class="content">foo xxx xxx</div>', target: '.content' }); up.layer.open({ content: '<div class="content">xxx</div>', target: '.content' })
    - It's OK for animations to run async after that
  - Test that ResetWorld is actually happening
  - Test that up.change({ content: 'foo' }) works when 'foo' is just text, without a wrapping tag
  - Test that we can submit a form into a new layer (success / fail)
  - Test up.proxy.cancel()
  - Test that closing a layer cancels all requests for that layer
  - Test that up.change(document: Element) works
  - Test that forms can submit as arbitrary layer changes (success and failure)
  - Test that [up-on-accepted] and [up-on-dismissed] get the link's layer as up.layer.current

- Docs
  - All layer-related options should be moved to a[up-layer] or form[up-layer] or both
  - Document changes in options { history } (now boolean) and { location } (now a string) changes
  - Documentation from Diff
  - up.preload() can now fail if preloading is disabled
  - Docs: up:form:submit event now has { options } to manipulate
  - Docs: up:link:follow event now has { options } to manipulate
  - Expose up.fragment.all() as experimental API
  - Update Card and Slide for Testing config (maxRequests => concurrency, preloadConcurrency, disable preloading entirely)
  - { navigate }
  - Document that up.on selector can be a function
  - I think the slow/recover events changed
  - New gerund-events (up:layer:opening)
  - { failOptions }
  - up.link.config
  - New up.Request properties (at least { origin }, { preflightLayer })
  - Publish up.Request#loadPage()
  - Document that { target } can be an array


Finishing up
------------

- Remove unused files after we copied all documentation
  - popup
  - modal
- Grep for TODO
- Test in all browsers
- Migrate cards
- Migrate a Webpacker app
- Fix up-guide
  - Simplify content-link, modal-link, drawer-link
    - This should just be layer-link
  - up_modal.sass


Accessibility
--------------

- A11Y: current layer should get [role=dialog] and [aria-modal=true], all parent layers should get [inert] and [aria-hidden: true]. Since the root layer has no containers, we should apply this to direct children
- A11Y: check if [inert] etc. are enough to have the browser rotate focus within the layer
- A11Y: opening a layer should focus the layer, optionally to [autofocus]
- A11Y: closing a layer should focus the element that opened the layer


Bootstrap integration
---------------------

- update or stop supporting unpoly-boostrap3
- should we have unpoly-bootstrap4?


Later?
------

- Does up.remove() clean up jQuery data?
- { peel } option for up.destroy
- Instead of a single event listener slot per layer, allow layer.addEventListener('closing')?
  - How is this different from up.layer.on('up:layer:closing') ?
- Do we want an ExtractPlan.BackButton? Turbolinks keep [up-keep] for back.
- Turn property-like API symbols into getter
  - e.g. up.layer.root instead of up.layer.root()
  - e.g. up.layer.current instead of up.layer.current()
- Support [up-target][up-class] and [up-target][up-fail-class] to set a class on the new fragment
  - But think how that would go together with [up-layer="new"][up-class="warning"]
- Support :destroy pseudo-class up up.change() target
- Do we need an API to change context from JS? from server via header?
- Make all module names uppercase.
  - In a ES6 world this would not even be so bad, or even necessary. import { Event } from 'up'. Event.emit(...).
  - Even consider dropping shortcuts so we always do up.Fragment.change(), up.Event.emit(...)
- Should up.reload / up.change etc. resolve to the updated elements?
- There should be a preload() function in up.proxy, but that should also take a request
  - For this we also need to decide whether up.proxy.preload() would reject unsafe requests
- { layer: 'swap' } - replaces the current overlay with the new layer
- { layer: 'solo' } - replaces all overlays with the new overlay
- form[up-target] without a target now looks funny
  - I now have form[up-follow] as a workaround
- When up:proxy:load is prevented, the request should be resolved with an AbortError
- Replace up.Response.isSuccess() with up.Response#ok
- Replace up.Response.isFatal() with !up.Response#body
- Emit up:proxy:fatal when responses are aborted due to user or timeout


Decisions
---------

- Entscheiden ob ich die [up-modal], [up-drawer], etc. Shortcuts behalten möchte
  - Für Docs?
  - Verwirrend dass es mehrere Möglichkeiten gibt, das gleiche zu machen?
  - up-layer="new"
  => Ja, behalten
- The up.layer package object should be a looked up to "current", since TK naturally expected this to be the current layer
  => Das bringt nichts, dann kann man ja eben nicht sich was wergmerken
- Is { navigate } is really the best name for the option? Maybe { solo } or similar?
  - Keeping { navigate } means we could also use it for A11Y things
  => Gibt keine bessere Idee
- { flavor } umbenennen in { mode }, { scheme } oder { interface }
  - mode: Evtl. habe ich später mal nicht-modale Layer?
  - mode: 'modal' ist doof
  => Es ist nichts wirklich besser
- Should [up-href] be [up-url] to match { url }?
  - No, it matches HTML5 or XHTML2
- Params
  - Separate { query } and [up-query] options
  - NEVER move URL query to payload params
  - GET submissions: Form values should override, not append (set, not add) values from query
- Do I really want up.Change.ResetWorld instead of <body> as root's default target?
  - Yes, if we cannot match an overlay target we want to reset the world
  - One could argue that we only need ResetWorld when we're creating a layer or updating an overlay
- Should up.emit without an element emit on the document or on the current layer? => Keep it on document, as it is now!


